<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Final Project</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Summer 2020</h1>
<h1 align="middle">Final Project: Toon Shader</h1>
<h2 align="middle">John Schulz, CS184-SU</h2>

<br><br>

<div align="middle">
<img src="images/topIm.png" align="middle" width="400px"/>
<div>
<h2 align="middle">Overview</h2>
<p>I decided to work on this project independently given the circumstances of being sheltered in place for COVID-19. For my project, I extrapolated my implementation in project four to include a toon shader, update the GUI to change specific aspects, and create a framework that allows graphics with mesh elements to be rendered with shaders. The ultimate goal was to return graphics such as the cow, bunny, and teapot used in previous tasks with shaders including the custom toon one I have crafted.</p>
<h2 align="left">Problem Description</h2>
<p align="left">For this final project, I combined aspects from all of the previous projects to create unique visualizations that reflect toon-like shading on complex 3D objects we have previously worked with. I wanted to make my project accessible for people with differing graphic expertise by implementing new adjustable GUI parameters to dynamically edit the graphics to fit the userâ€™s desire. My final deliverables show how easily someone can modify my shader and the resultant graphic by simply inputting new values and changing slider values. My implementation reflects a high-quality toon shader with specular highlights, diffuse illumination, and outlines that all together create visually pleasing graphics for abstract and complex objects. </p>

<h2 align="left">Part 1: Toon Shader</h2>
<p align="left"> The toon shader I implemented consists of three parts that together create toon-like graphics. More specifically, my shader consists of specular highlights, diffuse illumination, and object outlines. These three shading techniques use Blinn Phong Shaing principles to systematically shade edges and surfaces in regard to the light and camera positions. Together, all aspects of my shader support each other and result in visually pleasing graphics regardless of the designated object.</p>
<h3 align="left">1. Specular Highlights</h1>
<p align="left"> To start, I added specular highlights with relation to the chosen color on the color wheel. Essentially, I added the color white multiplied by the designated specular intensity to the chosen color if the interested location on the object was being intersected by the light in relation to the camera position. I checked this condition by calculating the half vector between the camera and the target position, normalizing this vector, completing the dot product with the vertex normal and checking if this value fell between the designated cut off point. Below are the initial results of applying specular shading only to a sphere: </p>


<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/spec.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="images/spec1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="left">2. Outlines</h1>
<p align="left"> After adding specular highlights to my shader, I introduced outlines to make a more profound shading that highlights the edges of the object. My implementation of outline detection included interpolating the desired thickness of the edge in relation to the camera direction and the vertex normal. If the dot product between the vertex normal and the camera direction fell within the designated threshold, I modified the outcolor to become black (in later parts of my implementation I allow for the user to select the outline color). Here are images of a sphere with only outlines applied: </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/outline.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="images/outline1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="left">3. Diffuse lighting</h1>
<p align="left"> Lastly, to add more dynamic and adaptable toon like graphics I introduced diffuse lighting to my shading implementation. Diffuse lighting allows for objects to blend their primary color with the outline color in a visually appealing way that considers light positions and the objects geometry. To implement diffuse lighting, I first found the reflection coefficient of the target location by taking the dot product of the light position and the vertex normal to check if the location satisfies a specific diffuse levels conditions. For each diffuse level which I evenly partitioned, I check if the specific location's reflection coefficient fell within the diffuse areas minimum and maximum value. If the specific location did satisfy the conditions, the difference between the primary color and the outline colored was multiplied by the specific diffuse level number and added to the outline color to reflect a transitional color. The final result of this portion are reflected in the sphere below: </p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/diffuse.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="images/diffuse1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="left">All Together</h1>
<p align="left"> When put together, these three toon shading techniques create visually pleasing graphics that reflect the objects geometry and the lighting it receives. Below are images of the sphere and the sphere with a cloth over it with my final toon shader implementation applied: </p>


<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/allTogether.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="images/allTogether1.png" align="middle" width="400px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>

<h2 align="left">Part 2: Introducing Complex Objects</h2>
<p align="left"> To best show of my shader, I had to expand the objects I could display beyond simple json files such as the sphere, plane and cloth we used in project 4. After hours of research, I determined that I could represent 3D objects such as the bunny, cow and dragon we used in previous projects by using .obj files to create meshes for shading. To simplify, my conversion from .obj file to a framework suitable for the structure used to represent json files, I utilized MIT's Obj loader class that helped create easily accessible object instances from a provided .obj file. Once my designated .obj file was converted to a object class instance I modified code within the cloth simulator to update vetices, normals, and uv coordinates for all of the triangles within the object. Ultimately, updating these values prepared these objects to become shaded with the shaders I implemeted in project 4 and more importantly the toon shader I described above. For your reference to designate a object file use the -w followed by the path to the file to complex 3d objects. Below are some results of my shader appied to abstract objects objects: </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/dragon.png" align="middle" width="400px"/>
      </td>
      <td>
        <img src="images/cow.png" align="middle" width="250px"/>
      </td>
    </tr>
  </table>
</div>

<img src="images/bridge.png" align="middle" width="650px"/>


<h2 align="left">Part 3: Updating GUI</h2>
<p align="left">After implementing a fully functioning implementation for toon shading all types of objects, I wanted to provide my users with tools to modify specific parameters for my toon shader. For each of the many parameters I introduced in my toon shader, I inserted a new GUI aspect so the user could dynamically change the shading to meet their desired result. To make space for these new GUI components, I removed all of the simulation components we used in project 4. With this open space, I inserted new modifiable sliders, color wheels, and number inputs all related to the toon shading implementation I described above. Below is an image of the GUI interface I included alongside the original appearance interface: </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/original.png" align="middle" width="400px"/>
      </td>
      <td>
        <img src="images/added.png" align="middle" width="340px"/>
      </td>
    </tr>
  </table>
</div>

<h3 align="left">Component Toggler</h1>
<p align="left">The first new GUI aspect I introduced was a component toggler for all three of the toon shading techniques I implemented. These togglers allow for users to easily select which aspect of my toon shading implementation they want to use. I implemented this by adding if statements to each part of my toon shader, each checking if the respective portion was toggled. Below are images of the same object with individual portions toggled: </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/spec3.png" align="middle" width="400px"/>
        <figcaption align="middle">Only Specular Highlights</figcaption>
      </td>
      <td>
        <img src="images/out3.png" align="middle" width="400px"/>
        <figcaption align="middle">Only Outline</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/diff3.png" align="middle" width="400px"/>
        <figcaption align="middle">Only Diffuse Lighting</figcaption>
      </td>
      <td>
        <img src="images/all.png" align="middle" width="400px"/>
        <figcaption align="middle">Full Implementation</figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="left">Outline Color Wheel</h1>
<p align="left"> I introduced a second color wheel to further adjust the color of my toon shader. Chaning the color wheel value changes the outline color and the transitional colors for diffuse lighting. </p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/color1.png" align="middle" width="500px"/>
        <figcaption align="middle"></figcaption>
      </td>
      <td>
        <img src="images/color2.png" align="middle" width="500px"/>
        <figcaption align="middle"></figcaption>
      </td>
    </tr>
  </table>
</div>

<h3 align="left">Slider Color Adapters</h1>



  <div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/fin3.png" align="middle" width="400px"/>
        <figcaption align="middle">Baseline</figcaption>
      </td>
      <td>
        <img src="images/changeBright.png" align="middle" width="413px"/>
        <figcaption align="middle">Shade Brightness</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/changeSize.png" align="middle" width="405px"/>
        <figcaption align="middle">Shading Size</figcaption>
      </td>
      <td>
        <img src="images/changeOut.png" align="middle" width="380px"/>
        <figcaption align="middle">Outline Size</figcaption>
      </td>
    </tr>
  </table>
</div>
<p> Below is an image of my cloth at its final resting state with Normal shading to show the tension on the wireframe. My colors came out different than the specs but it appears to have the same relative behavior for each section of the cloth.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/p2.png" align="middle" width="400px"/>
        <figcaption align="middle">Final Resting State</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Part 3: Handling Collisions with Other Objects</h2>
<p>Implementation: After implementing how point massâ€™s and the cloth, in general, changed when forces were applied to it, I started to consider how a cloth interacted with other surfaces such as spheres and planes. First, I handled collisions with spheres by using the relationship between the clothâ€™s trajectory and the tangent point where the cloth would meet the sphere. If the point massâ€™s next positions intersected or fell within the sphere, I updated its position by adding a scaled difference between the tangent point and the point massâ€™s last position. Following the handling of collisions with spheres, I implemented how points reacted to collisions with planes. If the point massâ€™s crossed through the plane (current position and last position on opposite sides), I found its tangent point by using the planes normal vector, calculated the correction vector (the difference between the tangent point and the last position), and updated the point massâ€™s position with this correction vector scaled and a surface offset to ensure the cloth layed above the plane. Lastly, I extended my previous simulation implementation to handle collisions by iterating through each point mass and running these unique collide methods on them for all the collisions that exist.</p>

<p>Below are images of a shaded cloth resting on a sphere with differing spring constat or ks values. As expected these images follow similar behaviors to the previus section where I displayed stiffer cloths with higher ks values and a more saggy cloth when ks values were smaller. When ks equals 50000 the cloth looks stiffer and fans out wider than when ks equals 500 and the cloth sags downward much more drastically. As I stated above, this occurs because the spring constant determines the springs elasticity and stiffness.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/5000.png" align="middle" width="400px"/>
        <figcaption align="middle">ks = 5000</figcaption>
      </td>
      <td>
        <img src="images/50000.png" align="middle" width="400px"/>
        <figcaption align="middle">ks = 50000</figcaption>
      </td>

    </tr>
    <tr>
      <td>
        <img src="images/500.png" align="middle" width="400px"/>
        <figcaption align="middle">ks = 500</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>Shaded cloth lying peacefully at rest on a plane.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/plane.png" align="middle" width="400px"/>
        <figcaption align="middle">Cloth Flat on a Plane</figcaption>
      </td>
    </tr>
  </table>
</div>


<h2 align="middle">Part 4: Handling self-collisions</h2>
<p>Implementation: In the previous part, I implemented how a cloth interacted with other objects, but I did not account for how the cloth collides with itself. To do this in a timely fashion, I implemented spatial hashing by constructing a hash table that maps unique floats to a vector of point massâ€™s. Before constructing my hash table, I created a hash function to truncate each point to the closest coordinate within a 3D box by using floor division and scalars. After defining my hash function, I iterated through each point mass and initialized a new point mass vector if the spatial map did not already account for the point. Ultimately, I used this spatial map for checking collisions between every point and their respective potential candidates. If the difference between the point mass and the candidate position was less than the threshold of two times the thickness and they arenâ€™t the same point mass object, I updated the point massâ€™s position by adding the average of all the correction vectors that were calculated using the difference of the current position and candidateâ€™s positions. The final result of this implementation is a cloth that folds on itself in a natural way that follows the rules of physics in the natural world.</p>
<p> A cloth collapsing on itself as captured with images that show it at an early state, mid state, and nearly resting state.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/early.png" align="middle" width="400px"/>
        <figcaption align="middle">Early State</figcaption>
      </td>
      <td>
        <img src="images/mid.png" align="middle" width="400px"/>
        <figcaption align="middle">Middle State</figcaption>
      </td>

    </tr>
    <tr>
      <td>
        <img src="images/rest.png" align="middle" width="400px"/>
        <figcaption align="middle">Nearly Resting State</figcaption>
      </td>
    </tr>
  </table>
</div>


<p> Below are four images that show how changing the density changes the behavior of self collisions on a cloth falling on a plane. In the top two images there is a lower density and we see the cloth fold more smootly and with less bends. Comparitively, for the two bottom images with a much higher density the cloth folds in on itself more often and there are resultantly more ruffles as the cloth collapses.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/lowDearly.png" align="middle" width="400px"/>
        <figcaption align="middle">Low Density Early State</figcaption>
      </td>
      <td>
        <img src="images/lowDlate.png" align="middle" width="400px"/>
        <figcaption align="middle">Low Density Late State</figcaption>
      </td>

    </tr>
    <tr>
      <td>
        <img src="images/highDearly.png" align="middle" width="400px"/>
        <figcaption align="middle">High Density Early State</figcaption>
      </td>
      <td>
        <img src="images/highDlate.png" align="middle" width="400px"/>
        <figcaption align="middle">High Density Late State</figcaption>
      </td>
    </tr>
  </table>
</div>

<h2 align="middle">Part 5: Shaders</h2>
<p>Shader Programs (implementation): This portion of the project consisted of implementing a series of shader programs to add textures, colors, and lighting to the cloth graphics we previously generated. To do this, I used GLSL, a language similar to C, to add color and shader attributes to graphic positions within the scene. For each task in this part, I implemented fragment shaders to write colors onto positions by using the vertex values that were rasterized using a vertex shader file. Together these vertex shaders and fragment shaders allowed me to portray lighting and material effects such as diffuse shading, Phong shading, mirror shading, and texture mapping. </p>

<p>Blinn-Phong Shading Model: To implement Blinn-Phong shading, I extrapolated from the first task of this part that added diffuse lighting by using the diffuse coefficient, kd, and illumination from the source. For Blinn-Phong shading, I used diffuse lighting in addition to ambient shading and specular shading. Ambient shading added a constant color for all positions that were intersected with. Specular shading is modeled similarly to diffuse lighting but using a different coefficient and highlights generate by a vector off a surface. Together, these three shading types come together to create _hong shading that is depicted below.</p>
<p> Blinn-Phong shader outputting only the ambient component, only outputting the diffuse component, only outputting the specular component, and finally one using the entire Blinn-Phong model.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/ambient.png" align="middle" width="400px"/>
        <figcaption align="middle">Only Ambient Component</figcaption>
      </td>
      <td>
        <img src="images/diffuse.png" align="middle" width="400px"/>
        <figcaption align="middle">Only Diffuse Component</figcaption>
      </td>

    </tr>
    <tr>
      <td>
        <img src="images/specular.png" align="middle" width="400px"/>
        <figcaption align="middle">Only Specular Component</figcaption>
      </td>
      <td>
        <img src="images/all.png" align="middle" width="400px"/>
        <figcaption align="middle">Entire Blinn-Phong Model</figcaption>
      </td>
    </tr>
  </table>
</div>

<p>A texture mapping shader using my own custom texture.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/texture.png" align="middle" width="400px"/>
        <figcaption align="middle">Texture Mapping</figcaption>
      </td>
    </tr>
  </table>
</div>
<p>A mirror shader showing the cloth with a reflective behavior.</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/mirror.png" align="middle" width="400px"/>
        <figcaption align="middle">Mirro</figcaption>
      </td>
    </tr>
  </table>
</div>


</body>
</html>
